// Modules
const mime = require("mime-types")
const { login } = require("./login")
const path = require("path")
const fs = require("fs")
const got = require("got")
const request = require("request-promise")
const sip = require("")

//Global Variables
exports.MESSAGE_TYPE = 0
exports.MULTIMEDIAMESSAGE_TYPE = 1

exports.SENT_MESSAGE_TYPE = 2
exports.RECEIVED_MESSAGE_TYPE = 1

//Classes
exports.Client = class {
    constructor(email) {
        this.email = email 
        this.name = email.split("@")[0]
        this.userSids = load()

        const keys = Object.keys(this.userSids)

        this.headers = {
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36'
        }
        if (keys.includes(this.email)) {
            this.headers.Cookie = "connect.sid=" + this.userSids[this.email]
        } else {
            const sid = login()
            this.headers.Cookie = "connect.sid=" + this.userSids[this.email]
            this.userSids[this.email] = sid
            save(this.userSids)
        }
    }

    //Functions
    auth_reset() {
        const sid = login()
        this.userSids[this.email] = sid
        save(this.userSids)
    }

    async getMessages() {
        const res = await got.get("https://www.textnow.com/api/users/" + this.name + "/messages",
            {
                headers: this.headers,
                responseType: "json"
            }
        )

        let messages = []
        for (let i = 0; i < res.body.messages.length; i++) {
            const msg = res.body.messages[i]
            const msgObj = await this.getMsgObject(msg)
            messages.push(msgObj)
        }
        
        return messages
    }

    async getReceivedMessages() {
        const msgs = await this.getMessages()
        const received = msgs.filter(msg => msg.direction === RECEIVED_MESSAGE_TYPE)

        return received
    }

    async getSentMessages() {
        const msgs = await this.getMessages()
        const sentMsgs = msgs.filter(msg => msg.direction == SENT_MESSAGE_TYPE)

        return sentMsgs
    }

    async getUnreadMessages() {
        const msgs = await this.getReceivedMessages()
        const unread = msgs.filter(msg => !msg.read)

        return unread
    }

    async getReadMessages() {
        const msgs = await this.getReceivedMessages()
        const read = msgs.filter(msg => msg.read)

        return read 
    }

    on(event, callback) {
        switch (event) {
            case 'message': {
                this.messageInterval = setInterval(async () => {
                    const msgs = await this.getUnreadMessages()
                    if (msgs.length != 0) {
                        for (let i = 0; i < msgs.length; i++) {
                            const msg = msgs[i]
                            await msg.markAsRead()
                            await callback(msg)
                        }
                    }
                }, 500)

                break
            }
        }
    }

    off(event) {
        switch (event) {
            case 'message': {
                try {
                    clearInterval(this.messageInterval)
                    return true
                }
                catch (err) {
                    return false
                }
            }
        }
    }

    async sendSMS(to, text) {
        const res = await got.post("https://www.textnow.com/api/users/" + this.name + "/messages", {
            json: {
                contact_value: to,
                contact_type: "2",
                message: text,
                read: "1",
                message_direction: "2",
                message_type: "1",
                from_name: this.name,
                has_video: false,
                new: true,
                date: (new Date()).toISOString()
            },
            headers: this.headers
        })
        
        return res.statusCode
    }
    /*
    async sendMMS(to, filepath) {
        const mimetype = mime.lookup(filepath)
        const fileType = mimetype.split("/")[0]
        const hasVideo = fileType == "video"
        const msgType = (fileType == "image") ? 2 : 4

        const fileHolder = await got.get("https://www.textnow.com/api/v3/attachment_url?message_type=2",
        {
            headers: this.headers,
            responseType: "json"
        })
        const url = fileHolder.body.result
        const data = fs.readFileSync(filepath)

        const headersPlaceFile = {
            'accept': '*',
            'content-type': mimetype,
            'accept-language': 'en-US,en;q=0.9',
            mode: "cors",
            method: "PUT",
            credentials: 'omit',
            Cookie: this.headers.Cookie
        }

        await got.put(url,
            {
                payload: data,
                headers: headersPlaceFile
            })
            
        const jsonData = {
            from_name: this.name,
            has_video: hasVideo,
            contact_value: to,
            contact_type: 2,
            read: 1,
            message_direction: SENT_MESSAGE_TYPE,
            message_type: msgType,
            new: true,
            date: (new Date()).toISOString(),
            attachment_url: encodeURI(url),
            media_type: fileType
        }
        
        const fileHeaders = Object.assign(this.headers)
        //fileHeaders['content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8'

        const options = {
            url: 'https://www.textnow.com/api/v3/send_attachment',
            method: 'POST',
            headers: fileHeaders,
            json: jsonData
        };
        const sendFile = await request(options)
        console.log(sendFile)
        console.log(sendFile.statusCode);
        return sendFile.statusCode
    }
    */

    async getMsgObject(msgObj) {
        const obj = {
            content: msgObj.message,
            number: msgObj.contact_value,
            date: Date.parse(msgObj.date),
            firstContact: msgObj.conversation_filtering.first_time_contact,
            read: msgObj.read,
            id: msgObj.id,
            direction: msgObj["message_direction"]
        }

        obj.type = (obj.content.startsWith("http")) ? MULTIMEDIAMESSAGE_TYPE : MESSAGE_TYPE
        obj.markAsRead = async () => {
            const base_url = "https://www.textnow.com/api/users/" + this.name + "/conversations/"
            const url = base_url + encodeURIComponent(obj.number)

            const params = {
                "latest_message_id": obj.id,
                "http_method": "PATCH"
            }

            const res = await got.post(url,
                {
                    searchParams: params,
                    data: '{"read": true}',
                    headers: this.headers
                })
            return res
        }

        if (obj.type == MULTIMEDIAMESSAGE_TYPE) {
            obj.url = obj.content
            delete obj.content
            
            const res = await got.get(obj.url, {headers: this.headers})
            obj.rawData = res.body
            obj.contentType = res.headers["content-type"]
            obj.extension = obj.contentType.split("/")[1]
            obj.mv = (filepath = null) => {
                filepath = (filepath) ? filepath : `file.${obj.extension}`
                if (!filepath.includes(".")) filepath += obj.extension
                fs.writeFileSync(filepath, obj.rawData)
            }
        }

        return obj
    }
}

// Functions
function load() {
    const filepath = path.resolve(__filename).split("\\").slice(0, -1).join("/") + "/user_sids.json"
    const data = fs.readFileSync(filepath)
    const obj = JSON.parse(data)

    return obj
}

function save(data) {
    const stringed = JSON.stringify(data)
    fs.writeFileSync(path.resolve("./user_sids.json"), stringed)
    return true
}
